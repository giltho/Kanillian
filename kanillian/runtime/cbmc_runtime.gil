#internal

(* Interestingly, there is no architecture importance to these now, since pointer
   is a distinct type from long/int *)

proc i__cbmc_binop_cmpl_le(v1, v2) {
        goto [ l-nth(v1, 0i) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "long" ] blon unde;
  blon: ret := l-nth(v1, 1i) i<= l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using long comparison operator for non-long elements")
};

proc i__cbmc_binop_cmpl_lt(v1, v2) {
        goto [ l-nth(v1, 0i) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "long" ] blon unde;
  blon: ret := l-nth(v1, 1i) i< l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using long comparison operator for non-long elements")
};

proc i__cbmc_binop_cmpl_ge(v1, v2) {
        goto [ l-nth(v1, 0i) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "long" ] blon unde;
  blon: ret := not (l-nth(v1, 1i) i< l-nth(v2, 1i));
        return;
  unde: fail[comparison]("Using long comparison operator for non-long elements")
};

proc i__cbmc_binop_cmpl_gt(v1, v2) {
      ir := "i__cbmc_binop_cmpl_le"(v1, v2);
      ret := not ir;
      return
};

proc i__cbmc_binop_cmpl_eq(v1, v2) {
        goto [ l-nth(v1, 0i) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "long" ] blon unde;
  blon: ret := l-nth(v1, 1i) i< l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using long comparison operator for non-long elements")
};


proc i__cbmc_binop_cmpu_le(v1, v2) {
        goto [ (l-nth(v1, 0i) = "int") and (l-nth(v2, 0i) = "int") ] bint unde;
  bint: ret := l-nth(v1, 1i) i<= l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Cannot compare non-comparable values")
};

proc i__cbmc_binop_cmpu_gt(v1, v2) {
      ir := "i__cbmc_binop_cmpu_le"(v1, v2);
      ret := not ir;
      return
};

proc i__cbmc_binop_cmpfs_ge(v1, v2) {
        goto [ l-nth(v1, 0i) = "single" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "single" ] blon unde;
  blon: ret := not (l-nth(v1, 1i) < l-nth(v2, 1i));
        return;
  unde: fail[comparison]("Using single comparison operator for non-single elements")
};

proc i__cbmc_binop_cmpfs_eq(v1, v2) {
        goto [ l-nth(v1, 0i) = "single" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "single" ] blon unde;
        (* FIXME: We should be using Z3 in float mode, not Real mode *)
  blon: ret := (l-nth(v1, 1i) = l-nth(v2, 1i));
        return;
  unde: fail[comparison]("Using single comparison operator for non-single elements")
};

proc i__cbmc_binop_cmpfs_ne(v1, v2) {
      ir := "i__cbmc_binop_cmpfs_eq"(v1, v2);
      ret := not ir;
      return
};

proc i__cbmc_binop_cmpf_eq(v1, v2) {
        goto [ l-nth(v1, 0i) = "float" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "float" ] blon unde;
        (* FIXME: We should be using Z3 in float mode, not Real mode *)
  blon: ret := (l-nth(v1, 1i) = l-nth(v2, 1i));
        return;
  unde: fail[comparison]("Using float comparison operator for non-float elements")
};

proc i__cbmc_binop_cmpf_ne(v1, v2) {
      ir := "i__cbmc_binop_cmpf_eq"(v1, v2);
      ret := not ir;
      return
};

proc i__cbmc_binop_cmpfs_le(v1, v2) {
        goto [ l-nth(v1, 0i) = "single" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "single" ] blon unde;
  blon: ret := l-nth(v1, 1i) <= l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using single comparison operator for non-single elements")
};


proc i__cbmc_binop_cmpu_eq(v1, v2) {
        goto [ (l-nth(v1, 0i) = "int") and (l-nth(v2, 0i) = "int") ] bint unde;
  bint: ret := l-nth(v1, 1i) = l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Cannot compare non-comparable values")
};

proc i__cbmc_binop_cmpu_ne(v1, v2) {
        ir := "i__cbmc_binop_cmpu_eq"(v1, v2);
        ret := not ir;
        return
};

proc i__cbmc_binop_cmplu_le(v1, v2) {
        goto [ (l-nth(v1, 0i) = "long") and (l-nth(v2, 0i) = "long") ] blon unde;
  blon: ret := (l-nth(v1, 1i) i<= l-nth(v2, 1i));
        return;
  unde: fail[comparison]("Cannot compare non-comparable values")
};

proc i__cbmc_binop_cmplu_lt(v1, v2) {
        goto [ (l-nth(v1, 0i) = "long") and (l-nth(v2, 0i) = "long") ] blon unde;
  blon: ret := (l-nth(v1, 1i) i< l-nth(v2, 1i));
        return;
  unde: fail[comparison]("Cannot compare non-comparable values")
};

proc i__cbmc_binop_cmplu_gt(v1, v2) {
      ir := "i__cbmc_binop_cmplu_le"(v1, v2);
      ret := not ir;
      return
};

proc i__cbmc_binop_cmplu_eq(v1, v2) {
        goto [ (l-nth(v1, 0i) = "long") and (l-nth(v2, 0i) = "long") ] blon unde;
  blon: ret := l-nth(v1, 1i) = l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Cannot compare non-comparable values")
};



proc i__cbmc_binop_cmpl_eq(v1, v2) {
        goto [ (l-nth(v1, 0i) = "long") and (l-nth(v2, 0i) = "long") ] blon unde;
  blon: ret := l-nth(v1, 1i) = l-nth(v2, 1i);
  unde: fail[comparison]("using long comparison operator for non-long elements")
};

proc i__cbmc_binop_cmpl_ne(v1, v2) {
      ir := "i__cbmc_binop_cmpl_eq"(v1, v2);
      ret := not ir;
      return
};

proc i__cbmc_binop_cmplu_ne(v1, v2) {
      ir := "i__cbmc_binop_cmplu_eq"(v1, v2);
      ret := not ir;
      return
};

proc i__cbmc_binop_cmp_gt(v1, v2) {
        goto [ l-nth(v1, 0i) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "int" ] blon unde;
  blon: ret := l-nth(v1, 1i) i> l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__cbmc_binop_cmp_ge(v1, v2) {
        goto [ l-nth(v1, 0i) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "int" ] blon unde;
  blon: ret := l-nth(v1, 1i) i>= l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__cbmc_binop_cmp_le(v1, v2) {
        goto [ l-nth(v1, 0i) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "int" ] blon unde;
  blon: ret := l-nth(v1, 1i) i<= l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__cbmc_binop_cmp_lt(v1, v2) {
        goto [ l-nth(v1, 0i) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "int" ] blon unde;
  blon: ret := l-nth(v1, 1i) i< l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__cbmc_binop_cmpu_lt(v1, v2) {
        goto [ l-nth(v1, 0i) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "int" ] blon unde;
  blon: ret := l-nth(v1, 1i) i< l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};

proc i__cbmc_binop_cmp_eq(v1, v2) {
        goto [ l-nth(v1, 0i) = "int" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "int" ] blon unde;
  blon: ret := l-nth(v1, 1i) = l-nth(v2, 1i);
        return;
  unde: fail[comparison]("Using int comparison operator for non-int elements")
};


proc i__cbmc_binop_cmp_ne(v1, v2) {
        ir := "i__cbmc_binop_cmp_eq"(v1, v2);
        ret := not ir;
        return
};

proc i__cbmc_unsign_int(v1) {
            goto [ l-nth(v1, 0i) = "int" ] iint unde;
            (* I should actually be checking for bounds here,
               but that's for later *)
      iint: assert (0i i<=# l-nth(v1, 1i)); (* It has to not overflow *)
            ret := v1;
            return;
      unde: fail[cast]("Using cast function for int on non-int elements")
};
 
 proc i__cbmc_unsign_long(v1) {
            goto [ l-nth(v1, 0i) = "long" ] iint unde;
      iint: assert(0i i<=# l-nth(v1, 1i)); (* It has to not overflow *)
            ret := v1;
            return;
      unde: fail[cast]("Using cast function for long on non-long elements")
};

proc i__cbmc_sign_long(v1) {
            goto [ l-nth(v1, 0i) = "long" ] iint unde;
            (* FIXME: I should actually be checking for bounds here,
               but I need to know what the bound is.
               It should be a paramter*)
      iint: ret := v1;
            return;
      unde: fail[cast]("Using cast function for long on non-long elements")
};

proc i__cbmc_sign_int(v1) {
            goto [ l-nth(v1, 0i) = "long" ] iint unde;
            (* FIXME: I should actually be checking for bounds here,
               but I need to know what the bound is.
               It should be a paramter*)
      iint: ret := v1;
            return;
      unde: fail[cast]("Using cast function for long on non-long elements")
};

proc i__cbmc_binop_addl(v1, v2) {
        goto [ l-nth(v1, 0i) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "long" ] blon unde;
  blon: ret := {{ "long", l-nth(v1, 1i) i+ l-nth(v2, 1i) }};
        return;
  unde: ret := undefined;
        return
};

proc i__cbmc_binop_mull(v1, v2) {
        goto [ l-nth(v1, 0i) = "long" ] llon unde;
  llon: goto [ l-nth(v2, 0i) = "long" ] blon unde;
  blon: ret := {{ "long", l-nth(v1, 1i) i* l-nth(v2, 1i) }};
        return;
  unde: ret := undefined;
        return
};